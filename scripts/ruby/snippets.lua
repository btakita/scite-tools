--[[
  Mitchell's ruby/snippets.lua
  Copyright (c) 2006-2007 Mitchell Foral. All rights reserved.

  SciTE-tools homepage: http://caladbolg.net/scite.php
  Send email to: mitchell<att>caladbolg<dott>net

  Permission to use, copy, modify, and distribute this file
  is granted, provided credit is given to Mitchell.
]]--

---
-- Snippets for the ruby module.
module('modules.ruby.snippets', package.seeall)

if not _G.snippets then _G.snippets = {} end

snippets[SCE_RB_DEFAULT] = {
  rb   = "#!`which ruby`",
  forin = "for ${1:element} in ${2:collection}\n  ${1}.${0}\nend",
  ife  = "if ${1:condition}\n  ${2:}\nelse\n  ${3:}\nend",
  ['if'] = "if ${1:condition}\n  ${0}\nend",
  case = "case ${1:object}\nwhen ${2:condition}\n  ${0}\nend",
  Dir  = "Dir.glob(${1:\"${2:dir/glob/*}\"}) do |${3:file}|\n  ${0}\nend",
  File = "File.foreach(${1:\"${2:path/to/file}\"}) do |${3:line}|\n  ${0}\nend",
  am   = "alias_method :${1:new_name}, :${2:old_name}",
  all  = "all? { |${1:e}| ${0} }",
  any  = "any? { |${1:e}| ${0} }",
  app  = "if __FILE__ == \\$PROGRAM_NAME\n  ${0}\nend",
  as   = "assert(${1:test}, \"${2:Failure message.}\")",
  ase  = "assert_equal(${1:expected}, ${2:actual})",
  asid = "assert_in_delta(${1:expected_float}, ${2:actual_float}, ${3:2 ** -20})",
  asio = "assert_instance_of(${1:ExpectedClass}, ${2:actual_instance})",
  asko = "assert_kind_of(${1:ExpectedKind}, ${2:actual_instance})",
  asm  = "assert_match(/${1:expected_pattern}/, ${2:actual_string})",
  asn  = "assert_nil(${1:instance})",
  asnm = "assert_no_match(/${1:unexpected_pattern}/, ${2:actual_string})",
  asne = "assert_not_equal(${1:unexpected}, ${2:actual})",
  asnn = "assert_not_nil(${1:instance})",
  asns = "assert_not_same(${1:unexpected}, ${2:actual})",
  asnr = "assert_nothing_raised(${1:Exception}) { ${0} }",
  asnt = "assert_nothing_thrown { ${0} }",
  aso  = "assert_operator(${1:left}, :${2:operator}, ${3:right})",
  asr  = "assert_raise(${1:Exception}) { ${0} }",
  asrt = "assert_respond_to(${1:object}, :${2:method})",
  assa = "assert_same(${1:expected}, ${2:actual})",
  asse = "assert_send([${1:object}, :${2:message}, ${3:args}])",
  ast  = "assert_throws(:${1:expected}) { ${0} }",
  rw   = "attr_accessor :${1:attr_names}",
  r    = "attr_reader :${1:attr_names}",
  w    = "attr_writer :${1:attr_names}",
  tc   = "require 'test/unit'\nrequire '${1:library_file_name}'\n\nclass Test${2:NameOfTestCases} < Test::Unit::TestCase\n  def test_${3:case_name}\n    ${0}\n  end\nend",
  cla  = "class ${1:ClassName}\n  ${0}\nend",
  cl   = "classify { |${1:e}| ${0} }",
  col  = "collect { |${1:e}| ${0} }",
  collect = "collect { |${1:element}| ${1}.${0} }",
  def  = "def ${1:method_name}\n  ${0}\nend",
  mm   = "def method_missing(meth, *args, &block)\n  ${0}\nend",
  defs = "def self.${1:class_method_name}\n  ${0}\nend",
  deft = "def test_${1:case_name}\n  ${0}\nend",
  deli = "delete_if { |${1:e}| ${0} }",
  det  = "detect { |${1:e}| ${0} }",
  ['do'] = "do ${1:|${2:arg}|}\n  ${0}\nend",
  doo  = "do |${1:object}|\n  ${0}\nend",
  each = "each { |${1:e}| ${0} }",
  eab  = "each_byte { |${1:byte}| ${0} }",
  eac  = "each_char { |${1:chr}| ${0} }",
  eaco = "each_cons(${1:2}) { |${2:group}| ${0} }",
  eai  = "each_index { |${1:i}| ${0} }",
  eak  = "each_key { |${1:key}| ${0} }",
  eal  = "each_line${1:} { |${2:line}| ${0} }",
  eap  = "each_pair { |${1:name}, ${2:val}| ${0} }",
  eas  = "each_slice(${1:2}) { |${2:group}| ${0} }",
  eav  = "each_value { |${1:val}| ${0} }",
  eawi = "each_with_index { |${1:e}, ${2:i}| ${0} }",
  fin  = "find { |${1:e}| ${0} }",
  fina = "find_all { |${1:e}| ${0} }",
  flao = "inject(Array.new) { |${1:arr}, ${2:a}| ${1}.push(*${2}) }",
  gre  = "grep(${1:/${2:pattern}/}) { |${3:match}| ${0} }",
  gsu  = "gsub(/${1:pattern}/) { |${2:match}| ${0} }",
  [':'] = ":${1:key} => ${2:\"${3:value}\"}${4:, }",
  is   = "=> ",
  inj  = "inject(${1:init}) { |${2:mem}, ${3:var}| ${0} }",
  lam  = "lambda { |${1:args}| ${0} }",
  map  = "map { |${1:e}| ${0} }",
  mapwi = "enum_with_index.map { |${1:e}, ${2:i}| ${0} }",
  max  = "max { |a, b| ${0} }",
  min  = "min { |a, b| ${0} }",
  mod  = "module ${1:ModuleName}\n  ${0}\nend",
  ope  = "open(${1:\"${2:path/or/url/or/pipe}\"}${3/^[rwab+]+$/, '/}${3:w}${3/^[rwab+]+$/'/}) do |${4:doc}|\n  ${0}\nend",
  par  = "partition { |${1:e}| ${0} }",
  ran  = "sort_by { rand }",
  rej  = "reject { |${1:e}| ${0} }",
  req  = "require '${0}'",
  rea  = "reverse_each { |${1:e}| ${0} }",
  sca  = "scan(/${1:pattern}/) { |${2:match}| ${0} }",
  sel  = "select { |${1:e}| ${0} }",
  sor  = "sort { |a, b| ${0} }",
  sorb = "sort_by { |${1:e}| ${0} }",
  ste  = "step(${1:2}) { |${2:n}| ${0} }",
  sub  = "sub(/${1:pattern}/) { |${2:match}| ${0} }",
  tim  = "times { ${1:n} ${0} }",
  uni  = "ARGF.each_line${1:} do |${2:line}|\n  ${0}\nend",
  unless = "unless ${1:condition}\n ${0}\nend",
  upt  = "upto(${1:1.0/0.0}) { |${2:n}| ${0} }",
  when = "when ${1:condition}\n  ${0}",
  zip  = "zip(${1:enums}) { |${2:row}| ${0} }",
  h    = "<% $0 %>",
  he   = "<%= $0 %>",
  eache = "each ${2/\\n/do/}${2/\\A.*\\z/{/} |${1:item}| ${2:} ${2/\\n/\\nend/}${2/\\A.*\\z/\\}/}${0} \\${3:}",
  c    = "# :${1:object_type}"
}
